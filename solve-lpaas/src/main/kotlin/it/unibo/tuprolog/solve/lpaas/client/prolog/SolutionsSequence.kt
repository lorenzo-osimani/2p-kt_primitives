package it.unibo.tuprolog.solve.lpaas.client.prolog

import io.grpc.ManagedChannel
import it.unibo.tuprolog.core.*
import it.unibo.tuprolog.core.parsing.parse
import it.unibo.tuprolog.solve.Solution
import it.unibo.tuprolog.solve.lpaas.*
import it.unibo.tuprolog.solve.lpaas.solveMessage.*

class SolutionsSequence(private val solverID: String, private val computationID: String, private val query: String,
    channel: ManagedChannel
): Iterator<Solution> {

    private val solutionsCache: MutableMap<Int, Solution> = mutableMapOf()
    private val stub = SolverGrpc.newFutureStub(channel)
    private val struct = Struct.parse(query)

    /**
     * @param index the index of the requested solution
     * @return The solution
     */
    fun getSolution(index: Int): Solution {
        if(!solutionsCache.containsKey(index)) {
            val reply = stub.getSolution(
                SolutionID.newBuilder().setSolverID(solverID).setComputationID(computationID)
                    .setQuery(query).setIndex(index).build()
            ).get()

            val scope = Scope.of(struct.args.filter { it.isVar }.map { it.castToVar() })

            if (reply.isYes) {
                val unifiers: MutableMap<Var, Term> = mutableMapOf()
                reply.substitutionList.forEach { pair ->
                    unifiers[scope.varOf(pair.`var`)] = Term.parse(pair.term)
                }
                solutionsCache[index] = Solution.yes(struct, Substitution.unifier(unifiers))
            } else {
                if(reply.error.isNotEmpty()) println(reply.error)
                solutionsCache[index] =
                    if (reply.isNo) Solution.no(struct)
                    /** Fix Error **/
                    else Solution.no(struct)
            }
        }
        return solutionsCache[index]!!
    }

    private var iteratorIndex = -1
    /**
     * @return the last element generated by iterator, null if empty
     */
    private fun getCurrentElement(): Solution? {
        return if(solutionsCache.isNotEmpty())
            solutionsCache[iteratorIndex]!!
        else null
    }

    override fun hasNext(): Boolean {
        return solutionsCache.isEmpty() || getCurrentElement()!!.isYes
    }

    override fun next(): Solution {
        return if(hasNext()) {
            return getSolution(++iteratorIndex)
        } else getCurrentElement()!!
    }
}