package it.unibo.tuprolog.solve.lpaas.client.prolog

import io.grpc.ManagedChannel
import it.unibo.tuprolog.core.*
import it.unibo.tuprolog.solve.*
import it.unibo.tuprolog.solve.data.CustomDataStore
import it.unibo.tuprolog.solve.exception.ResolutionException
import it.unibo.tuprolog.solve.lpaas.SolverGrpc
import it.unibo.tuprolog.solve.lpaas.solveMessage.SolutionID
import it.unibo.tuprolog.solve.lpaas.util.parsers.SolverDeserializer.deserializer
import it.unibo.tuprolog.solve.lpaas.util.parsers.SolverSerializer.serialize


class SolutionsSequence(private val solverID: String, private val computationID: String, private val struct: Struct,
    channel: ManagedChannel
): Iterator<Solution> {

    private val solutionsCache: MutableMap<Int, Solution> = mutableMapOf()
    private val stub = SolverGrpc.newFutureStub(channel)
    private var hasNext = false

    /**
     * @param index the index of the requested solution
     * @return The solution
     */
    fun getSolution(index: Int): Solution {
        if(!solutionsCache.containsKey(index)) {
            val reply = stub.getSolution(
                SolutionID.newBuilder().setSolverID(solverID).setComputationID(computationID)
                    .setQuery(struct.serialize()).setIndex(index).build()
            ).get()

            val unifiers: MutableMap<Var, Term> = mutableMapOf()
            val scope = Scope.of(struct)
            reply.substitutionList.forEach { pair ->
                val variable = deserializer.deserialize(pair.`var`).castToVar()
                val term = deserializer.deserialize(pair.term)
                unifiers[scope.varOf(variable.name)] = term
            }

            solutionsCache[index] = if (reply.isYes) {
                Solution.yes(struct, Substitution.unifier(unifiers))
            } else if (reply.isNo) {
                Solution.no(struct)
            } else
                Solution.halt(struct, ResolutionException(
                    Throwable(reply.error.message), object : ExecutionContext by DummyInstances.executionContext {
                        override val procedure: Struct = struct
                        override val substitution: Substitution.Unifier = Substitution.unifier(unifiers)
                        override val logicStackTrace: List<Struct> = reply.error
                            .logicStackTraceList.map { deserializer.deserialize(it).castToStruct() }
                        override val startTime: TimeInstant = reply.error.startTime
                        override val maxDuration: TimeDuration = reply.error.maxDuration
                        override val customData: CustomDataStore = CustomDataStore.empty().copy(reply.error.customDataStoreList.associate {
                            Pair(it.name, it.value)
                        })
                    }))
            hasNext = reply.hasNext
        }
        return solutionsCache[index]!!
    }

    private var iteratorIndex = -1
    /**
     * @return the last element generated by iterator, null if empty
     */
    private fun getCurrentElement(): Solution? {
        return if(solutionsCache.isNotEmpty())
            solutionsCache[iteratorIndex]!!
        else null
    }

    override fun hasNext(): Boolean {
        return solutionsCache.isEmpty() || hasNext
    }

    override fun next(): Solution {
        return if(hasNext()) {
            iteratorIndex += 1
            return getSolution(iteratorIndex)
        } else getCurrentElement()!!
    }
}