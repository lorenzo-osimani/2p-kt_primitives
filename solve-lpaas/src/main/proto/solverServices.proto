syntax = "proto3";

option java_multiple_files = true;
option java_package = "it.unibo.tuprolog.solve.lpaas";
option java_outer_classname = "LPaaS";

package lpaas;

/* Solver Service */

import "solveMessages.proto";

service Solver {
  rpc Solve(SolveRequest) returns (SolutionSequence) {}
  rpc GetSolution(SolutionID) returns (SolutionReply) {}
  rpc WriteOnInputChannel(stream LineEvent) returns (LineEvent) {}
  rpc ReadFromOutputChannel(OutputChannelMessage) returns (stream LineEvent) {}
  rpc GetFlags(SolverID) returns (Flags) {}
  rpc GetStaticKB(SolverID) returns (stream Theory.Clause) {}
  rpc GetDynamicKB(SolverID) returns (stream Theory.Clause) {}
  rpc GetLibraries(SolverID) returns (Runtime) {}
  rpc GetUnificator(SolverID) returns (Unificator) {}
  rpc GetOperators(SolverID) returns (OperatorSet) {}
  rpc GetInputChannels(SolverID) returns (Channels) {}
  rpc GetOutputChannels(SolverID) returns (Channels) {}
}

/* Solver Factory Service*/

import "solverFactoryMessages.proto";

service SolverFactory {
  rpc SolverOf(SolverRequest) returns (SolverReply) { }
  rpc SolverWithDefaultBuiltIns(SolverRequest) returns (SolverReply) { }
  rpc MutableSolverOf(SolverRequest) returns (SolverReply) { }
  rpc MutableSolverWithDefaultBuiltIns(SolverRequest) returns (SolverReply) { }
}

/* Solver service to modify at dynamically a server */

import "mutableSolverMessages.proto";

service MutableSolver {
  rpc LoadLibrary(MutableLibrary) returns (OperationResult) { }
  rpc UnloadLibrary(MutableLibrary) returns (OperationResult) { }
  rpc SetLibraries(MutableRuntime) returns (OperationResult) { }

  rpc LoadStaticKB(stream MutableClause) returns (OperationResult) { }
  rpc AppendStaticKB(stream MutableClause) returns (OperationResult) { }
  rpc ResetStaticKb(SolutionID) returns (OperationResult) { }

  rpc LoadDynamicKB(stream MutableClause) returns (OperationResult) { }
  rpc AppendDynamicKB(stream MutableClause) returns (OperationResult) { }
  rpc ResetDynamicKb(SolutionID) returns (OperationResult) { }

  rpc AssertA(MutableClause) returns (OperationResult) { }
  rpc AssertZ(MutableClause) returns (OperationResult) { }

  rpc Retract(MutableClause) returns (Theory) { }
  rpc RetractAll(MutableClause) returns (Theory) { }

  rpc setFlag(MutableFlag) returns (OperationResult) { }
}

// Liste bloccanti per quando si fanno input-output channel
// Stampe canale output, fa da quel momento in poi o anche prima?

//serializza execution context, opzionale custom data store (conversione in stringa di Any)


